### 1、访问元素&组件

1.1、访问根组件

​        方法： $root

可以访问root，也就是实例、

1.2、访问父组件

  1.2.1 方法：$parent

 提供了一种子组访问父组件的实例，这种方法可以替代父组件吧数据已prop的方式传入子组  件以供子组件使用的方式。当然，无论哪种方式，都不建议子组件直接修改父组件的数据。应该采取一个媒介。

 这种方式还有一个缺点就是只能$parent只能访问自己的直接父组件，一旦嵌套过深，代码就无法维护了。所以就出现了依赖注入的原因。

1.3、访问子组件或者子元素

​        1.3.1 $children

  $children打印的是一个VueCompoent的对象，这个对象里面包含了若干个子组件，以及其他的一些元素属性。要想访问某一个子组件，只能通过下标去访问，但是这种方法有很大的缺陷。

  一旦，子组件的顺序更改了或者子组件列表中间插入了一个别的组件，那么这个下标访问到的子组件很可能就是我们所需要的那个子组件了。

​        1.3.2 $refs

  $refs就解决了上述的问题，这种方法的机制是为子组件上添加一个ref属性，这个属性可以填字符串字面量，如果与v-bind绑定，也可以填一些变量等。而父组件中可以通过 refs来获取所有的有ref属性的子组件对象集合，这样就可以精准定位到你所需要的子组件了。

  当 `ref` 和 `v-for` 一起使用的时候，你得到的$ ref 将会是一个包含了对应数据源的这些子组件的数组。

> `$refs` 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 `$refs`。         

1.4、依赖注入

当一个一些后代组件都需要访问他们的同一个祖先组件的数据或者方法的时候，如果用$parent容易调用过深，parnet 无法很好的扩展到更深层级的嵌套组件上。所以就引入了依赖注入。

依赖注入引入了两个新的实例选项：`provide` 和 `inject`

`provide`是用来实现祖先组件期望提供给后代组件的数据和方法的一个函数。

`inject`是后代组件用来接收祖先组件传递给后代组件的数据和方法的一个函数。

```js
//祖先元素用来提供给后代元素的数据和属性的方法
provide: function () {
  return {
    getMap: this.getMap
  }
}
//在任何后代组件中，都可以通过这个方法接收指定的我们期望的数据和属性
inject: ['getMap']
```

这样做也是有坏处的

- ​     祖先组件不知道哪些后代组件会使用它提供的属性数据
- ​     后代组件也不知道被注入的property来自哪里
- ​     而且它使得代码的重构变得困难，同时这种方式提供的property是非响应式的。

#### 2、程序化的事件侦听器

$emit是子组件使用事件向外抛出一个值，父组件在组件外用`v-on`来监听该事件，当该事件触发的时候 

