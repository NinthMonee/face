## 一、正则表达式基础

### 1、两种创建方式   

####  （1）构造函数创建

```
var reg=new RegExp(正则内容，修饰符);
```

####  （2）字面量创建

```
var reg=\正则内容\修饰符;
```

### 2、对象方法

正则是用于字符串中的，所以除了正则对象本身自带的方法之外，字符串中的部分方法也可以用正则表达式。

|  方法   |                             解释                             |
| :-----: | :----------------------------------------------------------: |
|  exec   | 检索字符串中指定的值。返回一个数组表示exec()参数中字符串匹配正则的内容，并确定其位置。 |
|  test   |          检索字符串中指定的值。返回 true 或 false。          |
| replace | 查询符合正则的内容，并替换，当使用全局匹配时，可以完成所有元素的匹配替换 |
|  match  |       在字符串中找到正则的匹配，并将结果返回为一个数组       |
| search  |    搜索第一个符合正则规则的内容，返回下标，不支持全局匹配    |
|  spilt  |                  按照某种正则规则切割字符串                  |

### 3、修饰符

| 修饰符 |    解释    |
| :----: | :--------: |
|   i    | 忽略大小写 |
|   g    |  全局匹配  |
|   m    |  多行匹配  |

### 3、元字符

| 元字符 |                 解释                 |
| :----: | :----------------------------------: |
|   .    | 匹配任意单个字符，除了换行和行结束符 |
|   \w   |        匹配[a-z A-Z]单词字符         |
|   \W   |            匹配非单词字符            |
|   \d   |           匹配[0-9]的数字            |
|   \D   |            匹配非数字字符            |
|   \s   |             匹配空白字符             |
|   \S   |            匹配非空白字符            |
|   \b   |             匹配单词边界             |
|   \B   |            匹配非单词边界            |
|   \0   |              匹配NULL符              |
|   \n   |              匹配换行符              |
|   \f   |              匹配换页符              |
|   \r   |              匹配回车符              |
|   \t   |              匹配制表符              |
|   \v   |            匹配垂直制表符            |
|  \xxx  |     匹配以八进制数xxx规定的字符      |
|  \xdd  |     匹配以十六进制数dd规定的字符     |
| \uxxxx | 匹配以十六制数xxxx规定的Unicode字符  |

### 4、量词

|  量词  |                描述                 |
| :----: | :---------------------------------: |
|   n+   |      匹配至少包含一个n的字符串      |
|   n*   |   匹配任何包含零个或多个n的字符串   |
|   n?   |   匹配任何包含零个或一个n的字符串   |
|  n{x}  |     匹配包含x个n的序列的字符串      |
| n{x,y} |      x和y为正整数，前面的模式       |
|   n$   |       匹配任何结尾为n的字符串       |
|   ^n   |       匹配任何开头为n的字符串       |
|  ?=n   |   匹配任何其后紧接字符串n的字符串   |
|  ?!n   | 匹配任何其后没有紧接字符串n的字符串 |

### 5、中括号

|  表达式  |             描述             |
| :------: | :--------------------------: |
|  [abc]   |   查找方括号之间的任何字符   |
|  [^abc]  | 查找任何不在方括号之间的字符 |
|  [0-9]   |      查找任何0至9的数字      |
|  [a-z]   | 查找任何从小写a到小写z的字符 |
|  [A-Z]   |   查找任何从大写A到Z的字符   |
|  [A-z]   | 查找任何从大写A到小写z的字符 |
|  [adgk]  |   查找给定集合内的任何字符   |
| [^adgkj] |   查找给定几个外的任何字符   |
|  [a\|b]  |          查找a或者b          |

### 6、大括号

| 表达式 |        描述         |
| :----: | :-----------------: |
| {0,1}  | 匹配0个或者1个字符  |
|  {0,}  | 匹配0到正无穷个字符 |
|  {1,}  | 代表至少有一个字符  |

### 7、捕获组

|   表达式   |                             描述                             |
| :--------: | :----------------------------------------------------------: |
|   (*x*)    |                **捕获组:** 匹配x并记住匹配项                 |
| (?<Name>x) | 具名捕获组匹配"x"并将其存储在返回的匹配项的groups属性中，该属性位于`<Name>`指定的名称下。尖括号(`<` 和 `>`) 用于组名。 |
|  (?:*x*)   | **非捕获组:** 匹配 “x”，但不记得匹配。不能从结果数组的元素中收回匹配的子字符串 |

### 8、边界与断言

| 表达式  |                             描述                             |
| :-----: | :----------------------------------------------------------: |
| x(?=y)  |         **前行断言**：紧随x之后有y的字符串内容匹配x          |
| x(?!y)  |         **前行否定断言**：紧随x之后没有y的时候匹配x          |
| (?<=y)x |            **向后断言**：x紧随y之后的情况下匹配x             |
| (?<!y)x |        **向后否定断言**：x没有紧随y之后的情况下匹配x         |
|    ^    |                        匹配输入的开头                        |
|    $    |                        匹配输入的结尾                        |
|   \b    | 匹配一个单词的边界这是一个字的字符前后没有另一个字的字符位置, 例如在字母和空格之间。需要注意的是匹配的单词边界不包括在匹配中。换句话说，匹配字边界的长度为零。`/\bm/` 在 "moon" 中匹配到 "m"，`/oon\b/` 在 "moon" 中匹配 "oon"， 因为 "oon" 是这个字符串的结尾, 因此后面没有单词字符 |
|   \B    | 匹配非单词边界。这是上一个字符和下一个字符属于同一类型的位置：要么两者都必须是单词，要么两者都必须是非单词，例如在两个字母之间或两个空格之间。字符串的开头和结尾被视为非单词。与匹配的词边界相同，匹配的非词边界也不包含在匹配中。例如，`/\Bon/` 在 “at noon” 中匹配 “on” ，`/ye\B/` 在 "possibly yesterday"中匹配"ye" 。 |

### 9、特殊字符

| 表达式 |                             描述                             |
| :----: | :----------------------------------------------------------: |
|   ？   | 如果**紧跟在任何量词 \*、 +、? 或 {} 的后面**，将会使量词变为**非贪婪**（匹配尽量少的字符），和缺省使用的**贪婪模式**（匹配尽可能多的字符）正好相反。例如，对 "123abc" 使用 `/\d+/` 将会匹配 "123"，而使用 `/\d+?/` 则只会匹配到 "1"。如果没有跟在量词之后，只是跟在普通字符后面，代表{0,1} |
|   \n   | n为一个正整数，对于正则表达式中与n括号匹配的最后一个字符串的反向引用。如果用于捕获组中，可以代表第一个捕获组的引用。也可以用作重复匹配，匹配字符串中连续存在连续的两个或两个以上的相同字符串匹配 |

## 二、正则案例练习

### 1、案例1

#### 题目描述：

​         为元素添加样式，且去掉重复的样式和多余的空格。

```js
//html
//<div class="div1 div2 div4"></div>
//js代码实现
init();
function init(){
    var div=document.querySelector("div");
    addClass(div,"div3    div6 div2    ");
}
//第一种
function addClass(elem,className){
    var arr1=elem.className.trim().spilt(/\s+/);
    var arr2=className.trim().spilt(/s+/);
    arr1.forEach(function(item){
       if(arr2.indexOf(item) < 0 )arr2.push(item); 
    });
    elem.className=arr2.join(" ");
}
//第二种
function addClass(elem,className){
    elem.className=(elem.className.trim()+" "+className.trim())
    .spilt(/s+/)
    .reduce(function(value,item){
        if(value.indexOfo(item)<0){
            value,push(item);
        }
    },[]);
}

function removeClass(elem,className){
    var arr=className.trim().spilt(/s+/);
    elem.className=elem.className.trim().split(/s+/).reduce(function(value,item){
        if(arr.indexOf(item)<0)value.push(item);
    },[]);
}
```

### 2、案例2

#### 题目描述：

将*var str="aaabbffddeeaaggfddssaaggeer";*转换为*显示a[7]b[2]d[4]*

```js
str=str.spilt("").sort().join("")
.match(/\w\1*g)
       .reduce(function(value,item){
    value+=item[0]+"["+item.length+"]";
},[]);
```

### 3、案例3_非贪婪匹配

#### 题目描述：

将标签替换为空字符串

```js
var str = "<p>Uber的这款无人车原型配备了多个<strong>摄像头</strong>、<em>激光雷达</em>以及<span>传感器</span>，可看清100米范围内任何方向的东西</p><br/><p>第二行内容，哎嘿，第二行内容</p>";

str=str.replace(/<.*?/>/g,function(item){
if(item==="<br/>") return "\n";
return "";
})
```

### 4、案例4_密码匹配

题目描述：

匹配密码，要求必须包含大写，小写，数值，且数值不能作为第一位使用。

```js
/^(?=\D+\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\W).{8,16}$/
```

