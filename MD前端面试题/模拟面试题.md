1.Vue-router 中route和router的区别

(1)$route是**获取路由信息**的一个对象，废话！说具体点！
这个东西它既然是获取路由信息滴，那么什么是路由信息，怎么获取，又为什么要获取呢？
**\*举个栗子：***
在实际项目中，我们经常会用到路由信息，比如：

**$route.path**
字符串，等于当前路由对象的路径，会被解析为绝对路径，如 “/shops/goods” 。

**$route.params**
对象，包含路由中的动态片段和全匹配片段的键值对 。

**$route.query**

对象，包含路由中查询参数的键值对。例如，对于 /home/news/detail/01?favorite=yes ，会得到$route.query.favorite == ‘yes’ 。

**$route.router**
路由规则所属的路由器（以及其所属的组件）。

**$route.matched**
数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。

**$route.name**
当前路径的名字，如果没有使用具名路径，则名字为空。

所以我们可以通过$route.来获取到路由里的这些信息为自己所用。这就是 $route！

(2)$router **的作用是进行路由跳转的**！就像jQuery里的window.location一样，起到的是导航的作用。
**\*举个栗子：***

$router.go(-1)，那么它就会从当前页面跳转到-1这个页面！

## 2.Vue-router 中hash模式和history模式的区别

大牛解答：hash模式url里面永远带着#号，我们在开发当中默认使用这个模式。那么什么时候要用history模式呢？如果用户考虑url的规范那么就需要使用history模式，因为history模式没有#号，是个正常的url适合推广宣传。当然其功能也有区别，比如我们在开发app的时候有分享页面，那么这个分享出去的页面就是用vue或是react做的，咱们把这个页面分享到第三方的app里，有的app里面url是不允许带有#号的，所以要将#号去除那么就要使用history模式，但是使用history模式还有一个问题就是，在访问二级页面的时候，做刷新操作，会出现404错误，那么就需要和后端人配合让他配置一下apache或是nginx的url重定向，重定向到你的首页路由上就ok啦。 

​	关于Vue的路由一直以来个人都觉得是一件很神奇的事情，一个单页面应用居然可以做到多路由跳转并按需加载页面代码。以往的做法都是通过锚点来定位对应的页面代码，而这种古老的操作方式最大的问题就是首屏加载缓慢，一次性加载了所有页面代码。

那么Vue-router又是怎么实现的呢？

首先，这个router有两种模式：hash模式（默认）、history模式（需配置mode: 'history'）

|          | hash                       | history          |
| -------- | -------------------------- | ---------------- |
| url显示  | 有#，很Low                 | 无#，好看        |
| 回车刷新 | 可以加载到hash值对应页面   | 一般就是404掉了  |
| 支持版本 | 支持低版本浏览器和IE浏览器 | HTML5新推出的API |

两者的原理：

### hash模式

我们先来认识下这位朋友#，这个#就是hash符号，中文名哈希符或锚点，当然这在我们前端领域姑且这么称呼。

然后哈希符后面的值，我们称之为哈希值。OK，接下来我们继续分析他的原理。路由的哈希模式其实是利用了`window可以监听onhashchange`事件，也就是说你的url中的哈希值（#后面的值）如果有变化，前端是可以做到监听并做一些响应（搞点事情），这么一来，即使前端并没有发起http请求他也能够找到对应页面的代码块进行按需加载。

后来人们给他起了一个霸气的名字叫前端路由，成为了单页应用标配。

### history模式

我们先介绍一下H5新推出的两个神器：pushState与replaceState

具体自行百度，简而言之，这两个神器的作用就是可以将url替换并且不刷新页面，好比挂羊头卖狗肉，http并没有去请求服务器该路径下的资源，一旦刷新就会暴露这个实际不存在的“羊头”，显示404。

那么如何去解决history模式下刷新报404的弊端呢，这就需要服务器端做点手脚，将不存在的路径请求重定向到入口文件（index.html），前后端联手，齐心协力做好“挂羊头卖狗肉”的完美特效。

至此，我们的前端路由在实现与展示效果上又更进了一步！

> 总之，pushState方法不会触发页面刷新，只是导致history对象发生变化，地址栏会有反应。

### 总结

传统的路由指的是：当用户访问一个url时，对应的服务器会接收这个请求，然后解析url中的路径，从而执行对应的处理逻辑。这样就完成了一次路由分发。

而前端路由是不涉及服务器的，是前端利用hash或者HTML5的history API来实现的，一般用于不同内容的展示和切换。

----------------------------- 补充 -----------------------------

history模式下，build之后本地 index.html 打开是无效的。

hash模式下，build之后本地 index.html 打开正常！

## 3.路由守卫

1. ### 全局前置守卫

   可以使用 `router.beforeEach` 注册一个全局前置守卫：

   ```
   const router = new VueRouter({ ... })
   
   router.beforeEach((to, from, next) => {
     // ...
   })
   ```

   当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 **等待中**。

   每个守卫方法接收三个参数：

   - **to: Route**: 即将要进入的目标 [路由对象](https://router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1)

   - **from: Route**: 当前导航正要离开的路由

   - **next: Function**: 一定要调用该方法来 **resolve** 这个钩子。执行效果依赖 `next` 方法的调用参数。

     - **next()**: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 **confirmed** (确认的)。
     - **next(false)**: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 `from` 路由对应的地址。
     - **next('/') 或者 next({ path: '/' })**: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 `next` 传递任意位置对象，且允许设置诸如 `replace: true`、`name: 'home'` 之类的选项以及任何用在 [`router-link` 的 `to` prop](https://router.vuejs.org/zh/api/#to) 或 [`router.push`](https://router.vuejs.org/zh/api/#router-push) 中的选项。
     - **next(error)**: (2.4.0+) 如果传入 `next` 的参数是一个 `Error` 实例，则导航会被终止且该错误会被传递给 [`router.onError()`](https://router.vuejs.org/zh/api/#router-onerror) 注册过的回调。

     **确保 `next` 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。**这里有一个在用户未能验证身份时重定向到 `/login` 的示例：

     ```
     // BAD
     router.beforeEach((to, from, next) => {
       if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })
       // 如果用户未能验证身份，则 `next` 会被调用两次
       next()
     })
     // GOOD
     router.beforeEach((to, from, next) => {
       if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })
       else next()
     })
     ```

2. ### **全局后置钩子**

   可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 `next` 函数也不会改变导航本身：

   ```
   router.afterEach((to, from) => {
     // ...
   })
   ```

3. ### 路由独享的守卫

   在路由配置上直接定义 `beforeEnter` 守卫：

   ```
   const router = new VueRouter({
     routes: [
       {
         path: '/foo',
         component: Foo,
         beforeEnter: (to, from, next) => {
           // ...
         }
       }
     ]
   })
   ```

   这些守卫与全局前置守卫的方法参数是一样的。

4. ### 组件内的守卫

   在路由组件内直接定义以下路由导航守卫：

   - `beforeRouteEnter`
   - `beforeRouteUpdate` (2.2 新增)
   - `beforeRouteLeave`      

   ```
   const Foo = {
     template: `...`,
     beforeRouteEnter (to, from, next) {
       // 在渲染该组件的对应路由被 confirm 前调用
       // 不！能！获取组件实例 `this`
       // 因为当守卫执行前，组件实例还没被创建
     },
     beforeRouteUpdate (to, from, next) {
       // 在当前路由改变，但是该组件被复用时调用
       // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
       // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
       // 可以访问组件实例 `this`
     },
     beforeRouteLeave (to, from, next) {
       // 导航离开该组件的对应路由时调用
       // 可以访问组件实例 `this`
     }
   }
   ```

`beforeRouteEnter` 守卫 **不能** 访问 `this`，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。

不过，你可以通过传一个回调给 `next`来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。

```
beforeRouteEnter (to, from, next) {
  next(vm => {
    // 通过 `vm` 访问组件实例
  })
}
```

注意 `beforeRouteEnter` 是支持给 `next` 传递回调的唯一守卫。对于 `beforeRouteUpdate` 和 `beforeRouteLeave` 来说，`this` 已经可用了，所以**不支持**传递回调，因为没有必要了。

```
beforeRouteUpdate (to, from, next) {
  // just use `this`
  this.name = to.params.name
  next()
}
```

这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 `next(false)` 来取消。

```
beforeRouteLeave (to, from, next) {
  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')
  if (answer) {
    next()
  } else {
    next(false)
  }
}
```

## 4.vue中keep-alive

keep-alive是Vue提供的一个抽象组件，用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在v页面渲染完毕后不会被渲染成一个DOM元素 

```
<keep-alive>
    <loading></loading>
</keep-laive>
```

当组件在keep-alive内被切换时组件的**activated、deactivated**这两个生命周期钩子函数会被执行

被包裹在keep-alive中的组件的状态将会被保留，例如我们将某个列表类组件内容滑动到第100条位置，那么我们在切换到一个组件后再次切换回到该组件，该组件的位置状态依旧会保持在第100条列表处

 有的产品可能会要求在每一次进入一个组件时页面的初始位置都是保持在顶部的，这里可以利用Vue中的滚动行为，但是前提是你是**HTML5 history模式**
 我们在创建一个router实例的时候，可以提供一个scrollBehavior方法，该方法会在用户切换路由时触发

```
const router=new VueRouter({
    routes:[
        {
            path:"/",
            component:Home
        }
    ],
    scrollBehavior(to,form,savedPosition){
    //scrollBehavior方法接收to，form路由对象
    //第三个参数savedPosition当且仅当在浏览器前进后退按钮触发时才可用
    //该方法会返回滚动位置的对象信息，如果返回false，或者是一个空的对象，那么不会发生滚动
    //我们可以在该方法中设置返回值来指定页面的滚动位置，例如：
     return {x:0,y:0}
    //表示在用户切换路由时让是所有页面都返回到顶部位置
    //如果返回savedPosition,那么在点击后退按钮时就会表现的像原生浏览器一样，返回的页面会滚动过到之前按钮点击跳转的位置，大概写法如下：
     if(savedPosition){
        return savedPosition
     }else{
       return {x:0,y:0}
     }
     //如果想要模拟滚动到锚点的行为:
     if(to.hash){
       return {
         selector:to.hash
       }
     }
 }
})
```

 还有一个方法就是利用我们上面说过的，在keep-alive激活会触发activated钩子函数，那么在该函数内设置scrollTop为0

被keep-alive包裹的动态组件或router-view会缓存不活动的实例，再次被调用这些被缓存的实例会被再次复用，对于我们的某些不是需要实时更新的页面来说大大减少了性能上的消耗，不需要再次发送HTTP请求，但是同样也存在一个问题就是被keep-alive包裹的组件我们请求获取的数据不会再重新渲染页面，这也就出现了例如我们使用动态路由做匹配的话页面只会保持第一次请求数据的渲染结果，所以需要我们在特定的情况下强制刷新某些组件

1. 利用include、exclude属性

   ```
   <keep-alive include="bookLists,bookLists">
         <router-view></router-view>
   </keep-alive>
   <keep-alive exclude="indexLists">
         <router-view></router-view>
   </keep-alive>
   ```

   include属性表示只有name属性为bookLists，bookLists的组件会被缓存，（注意是组件的名字，不是路由的名字）其它组件不会被缓存exclude属性表示除了name属性为indexLists的组件不会被缓存，其它组件都会被缓存

2. 利用meta属性

   ```
   export default[
    {
     path:'/',
     name:'home',
     components:Home,
     meta:{
       keepAlive:true //需要被缓存的组件
    },
    {
     path:'/book',
     name:'book',
     components:Book,
     meta:{
        keepAlive:false //不需要被缓存的组件
    } 
   ]
   ```

   ```
   <keep-alive>
     <router-view v-if="this.$route.meat.keepAlive"></router-view>
     <!--这里是会被缓存的组件-->
   </keep-alive>
   <keep-alive v-if="!this.$router.meta.keepAlive"></keep-alive>
   <!--这里是不会被缓存的组件-->
   ```

## 5.vue生命周期钩子

- [ ] ![clipboard.png](https://segmentfault.com/img/bVEo3w?w=1200&h=2800) 

![f847b38a-63fe-11e6-9c29-38e58d46f036.png](https://segmentfault.com/img/bVEs9x?w=847&h=572) 

### create和mounted相关

在chrome浏览器里打开，F12看console可以发现

​	beforecreated:el和data并未初始化

​	created:完成了数据data的初始化，el没有

​	beforeMount:完成了el和data初始化

​	mounted:完成挂载

在标红处，发现el还是{{message}},这里就是应用的Virtual Dom(虚拟Dom)技术，先占住坑，到后面mounted挂载的时候再把值渲染进去

​	![clipboard.png](https://segmentfault.com/img/bVHMfj?w=588&h=475) 



### 生命周期钩子使用：

​	beforecreate:可以加个loading事件

​	created:在这结束loading,还可以做一些初始化，实现函数自执行

​	mounted:可以在这发起后端请求，拿数据，配合路由钩子做一些事情

​	beforeDestroy:你确认删除XX吗？

​	destroyed:删除当前组件，清空相关内容

## 6.vue 组件中的 data 为什么必须是函数

​	在创建或注册模板的时候传入一个 data 属性作为用来绑定的数据。但是在组件中,data必须是一个函数,因为每一个 vue 组件都是一个 vue 实例,通过 new Vue() 实例化,引用同一个对象,如果 data 直接是一个对象的话,那么一旦修改其中一个组件的数据,其他组件相同数据也会被修改

## 7.简述ES6的新特性

## 8.Koa 与 Express 比较

## 9.什么是服务端渲染，服务端渲染的优点

## 10.React 组件间信息传递

## 11.为什么有时连续多次setState只有一次生效？

## 12.React状态管理工具都有哪些？redux actionCreator都有什么？

## 13.什么是高阶组件、受控组件、非受控组件？

## 14.vuex和redux的区别？

## 15.http的缓存机制？

## 16.什么是数组扁平化，实现扁平化的方法有哪些？

## 17.什么是回流、重绘？

## 18.webpack中在使用babel插件处理js代码的时候，为什么使用polyfill，如何使用polyfill ？

## 19、HTML5 存储类型有什么区别？

HTML5 能够本地存储数据，在之前都是使用 cookies 。HTML5 提供了两种本地存储方案： localStorage 用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。 sessionStorage 同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。

## 20、使用箭头函数应注意什么？

（1）用了箭头函数，this就不是指向window，而是父级（指向是可变的）
（2）不能够使用arguments对象
（3）不能用作构造函数，所以不能使用new命令，否则会报错
（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数

## 21、简述es6的新特性

1.增加块作用域
2.增加let const
3.解构赋值
4.函数参数扩展 （函数参数可以使用默认值、不定参数以及拓展参数）
5.增加class类的支持
6.增加箭头函数
7.增加模块和模块加载
8.增加新的API math, number, string, array, object

## 22、请介绍一下Node事件循环的流程

在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理。如果有就取出事件及其相关的回调函数。然后进入下一个循环，如果不再有事件处理，就退出进程。

## 23、Redux遵循的三个原则是什么？

单一数据来源：整个应用的状态存储在单个 store 中的对象/状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。
状态是只读的：改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象。就像 state 是数据的最小表示一样，该操作是对数据更改的最小表示。
使用纯函数进行更改：为了指定状态树如何通过操作进行转换，需要用纯函数。纯函数是那些返回值仅取决于其参数值的函数。

## 24、为什么JavaScript是单线程？

作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，浏览器不知道该以哪个线程为主，单线程这已经成了这门语言的核心特征。
为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。

## 25.节流和防抖

防抖：就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
假设我们网站有个搜索框，用户输入文本我们会自动联想匹配出一些结果供用户选择。
节流：就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率
滚动浏览器滚动条的时候，更新页面上的某些布局内容或者去调用后台的某接口查询内容。

## 26.html5的语义化标签给我们带来了啥好处

结构清晰
可读性好
便于团队维护开发
搜索引擎可根据标签的语言确定上下文和权重问题，
容易被搜索引擎抓住机会

## 27.computed和watch的区别？

computed：
如果不使用计算属性，那么 message.split('').reverse().join('') 就会直接写到 template 里，那么在模版中放入太多声明式的逻辑会让模板本身过重，尤其当在页面中使用大量复杂的逻辑表达式处理数据时，会对页面的可维护性造成很大的影响，而且计算属性如果依赖不变的话，它就会变成缓存，computed 的值就不会重新计算。而且他返回的是一个值，同时也不能进行异步操作。所以就有了watch。
watch也是用来监听数据的变化的，watch与computed的区别就是它支持异步，不支持缓存。而且watch在第一次监听的时候不会触发，想要触发必须得在第二个参数上面配置（immeiate）。此外还有另外一个参数是deep，可以用来深度监听一个数组或者是对象。

## 28.v-if 和 v-show 区别

v-show 只是在 display: none 和 display: block 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说 v-show 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。
v-if 的话就得说到 Vue 底层的编译了。当属性初始为 false 时，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。
并且基于 v-if 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。

## 29.vue中的key

​    key 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。所以key 的作用主要是为了高效的更新虚拟 DOM。

## 30.git怎么删除远程和本地分支

git branch 查看本地分支

删除本地分支，删除需要删除的分支之前切换到别的分支然后执行，git branch --delete 分支名字

删除远程分支，git push origin --delete 分支的名字。 

## 31.div+css 的布局较 table 布局有什么优点？ 

改版的时候更方便 只要改 css 文件。
页面加载速度更快、结构化清晰、页面显示简洁。
表现与结构相分离。
易于优化（seo）搜索引擎更友好，排名更容易靠前。

a> div+css布局的好处：
1.符合W3C标准，代码结构清晰明了，结构、样式和行为分离，带来足够好的可维护性。
2.布局精准，网站版面布局修改简单。
3.加快了页面的加载速度（最重要的）。
4.节约站点所占的空间和站点的流量。
5.用只包含结构化内容的HTML代替嵌套的标签，提高另外搜索引擎对网页的搜索效率。
b> table布局的好处（table布局也不是一点用的没有，这点是毋庸置疑的）
1.容易上手。
2.可以形成复杂的变化，简单快速。
3.表现上更加“严谨”，在不同浏览器中都能得到很好的兼容。

## 32.vue路由懒加载方式 

方法一 resolve
这一种方法较常见。它主要是使用了resolve的异步机制，用require代替了import,实现按需加载

方法二 官网方法
vue-router在官网提供了一种方法，可以理解也是为通过Promise的resolve机制。因为Promise函数返回的Promise为resolve组件本身，而我们又可以使用import来导入组件。

方法三 require.ensure
这种模式可以通过参数中的webpackChunkName将js分开打包。
component: resolve => require.ensure([], () => resolve(require(’@/components/’+componentName)), ‘webpackChunkName’)

结合 Vue 的异步组件和 Webpack 的代码分割功能，把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件

## 33.redux工作流程 

首先，用户发出 Action。然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。State 一旦有变化，Store 就会调用监听函数。listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。 

## 34.Es6 module和commonjs的区别 

CommonJS和ES6 Module是目前使用较为广泛的模块标准。它们的主要区别在于 1.前者建立模块依赖关系是在运行时，后者是在编译时； 2.在模块导入方面，CommonJS导入的是值拷贝，ES6 Module导入的是只读的变量映射； 3.ES6 Module通过其静态特性可以进行编译过程中的优化，并且具备处理循环依赖的能力。 

## 35.hash、chunkhash、contenthash三者区别 

一、hash（所有文件哈希值相同，只要改变内容跟之前的不一致，所有哈希值都改变，没有做到缓存意义） 二、chunkhash（同一个模块，就算将js和css分离，其哈希值也是相同的，修改一处，js和css哈希值都会变，同hash，没有做到缓存意义） 三、contenthash（只要文件内容不一样，产生的哈希值就不一样） 

## 36.React 中 keys 的作用是什么？ 

Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。 在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。 

## 37.React中keys的作用是什么 

优化性能，避免渲染无辜DOM节点 

## 38.为什么我们要用hook 

避免一个方法在多个生命周期执行 

## 39.redux中使用setState不能立即获取值，怎么办 

传入函数或者在第二个参数写一个回调‘’ ‘redux中state不可变性 有利于react渲染节点。避免深遍历造成性能浪费 

## 40.强缓存与协商缓存的区别

强缓存客户端不需要重复发HTTP请求，协商缓存则不发送HTTP请求  

## 41.Vue中单项数据流 

单项数据流主要是父组件传给子组件的数据父组件只能渲染而不能修改。 

## 42.Vue组件中的data为什么是一个函数，根组件却是对象 

# [vue中组件的data为什么是一个函数](https://www.cnblogs.com/yuerdong/p/11395410.html)

组件是可复用的`vue`实例，一个组件被创建好之后，就可能被用在各个地方，而组件不管被复用了多少次，组件中的`data`数据都应该是相互隔离，互不影响的，基于这一理念，组件每复用一次，`data`数据就应该被复制一次，之后，当某一处复用的地方组件内`data`数据被改变时，其他复用地方组件的`data`数据不受影响

为什么根实例的data是一个对象？

答：new Vue()中只有一个data属性，共用该data。

## 43.浏览器端 Event loop 

执行栈在执行完**同步任务**后，查看**执行栈**是否为空，如果执行栈为空，就会去检查**微任务**(`microTask`)队列是否为空，如果为空的话，就执行`Task`（宏任务），否则就一次性执行完所有微任务。 每次单个**宏任务**执行完毕后，检查**微任务**(`microTask`)队列是否为空，如果不为空的话，会按照**先入先**出的规则全部执行完**微任务**(`microTask`)后，设置**微任务**(`microTask`)队列为`null`，然后再执行**宏任务**，如此循环。 

## 44、跨域的解决方案 

跨域问题来源于浏览器同源策略的限制问题导致的

而浏览器设置同源策略是因为 防止浏览器收到xss 和 csrf的工资

第一种：可以通过JSONP的原理：img ，script，link。

jsonp只支持get的请求方式，也容易受到`xss`的攻击

第二种：后端设置cros

第三种：服务器代理

第四种：sock

## 45、你都做过哪些Vue的性能优化

## 编码阶段

- 尽量减少`data`中的数据，`data`中的数据都会增加`getter`和`setter`，会收集对应的`watcher`
- `v-if`和`v-for`不能连用
- 如果需要使用`v-for`给每项元素绑定事件时使用事件代理
- `SPA` 页面采用`keep-alive`缓存组件
- 在更多的情况下，使用`v-if`替代`v-show`
- `key`保证唯一
- 使用路由懒加载、异步组件
- 防抖、节流
- 第三方模块按需导入
- 长列表滚动到可视区域动态加载
- 图片懒加载

## `SEO`优化

- 预渲染
- 服务端渲染`SSR`

## 打包优化

- 压缩代码
- `Tree Shaking/Scope Hoisting`
- 使用`cdn`加载第三方模块
- 多线程打包`happypack`
- `splitChunks`抽离公共文件
- `sourceMap`优化

## 用户体验

- 骨架屏
- `PWA`

> 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启`gzip`压缩等。

## 46、什么是 JSX 

JSX是javascript的语法扩展。它就像一个拥有javascript全部功能的模板语言 在里面可以使用js代码{}

它实现的原理就是react封装了createElement（第一个参数是 标签名，第二个参数是对象 包含了所有的属性，第三个是 子节点）。

## 47、那你再说一说Loader和Plugin的区别 

## 48、nextTick知道吗，实现原理是什么 

`nextTick`批量异步更新策略，一句话概括**在下次DOM更新循环结束之后执行延迟回调**。它主要是为了解决：例如一个`data`中的数据它的改变会导致视图的更新，而在某一个很短的时间被改变了很多次，假如是1000次，每一次的改变如果都都将促发数据中的`setter`并按流程跑下来直到修改真实DOM，那DOM就会被更新1000次，这样的做法肯定是非常低效的。

而在目前浏览器平台并没有实现`nextTick`方法，所以Vue.js 源码中分别用 `Promise`、`setTimeout`、`setImmediate` 等方式定义了一个异步方法nextTick，它接收的是一个回调函数，多次调用nextTick会将传入的回调函数存入队列中，当当前栈的任务都执行完毕之后才来执行这个队列中刚刚存储的那些回调函数，并且通过这个异步方法清空当前队列。

## 49、React 新老版生命周期函数 

Render函数靠mouting时触发，如果在里面调用状态会造成死循环
componentWillMount
相当于vue中的beforemount,在dom渲染之前触发的

componentDidMount
在dom渲染完之后，是一个创建时期调用的钩子

componentWillReceiveProps(props.state)
检测父组件给的信息，一有变化就会run

componentWillUnmount
在组件被卸载时调用

shouldComponentUpdata钩子:
此钩子新老版生命周期函数中都存在，主要用于在渲染之前，判断是否执行渲染，相当于一个开关，当执行结果为false时不会触发后面的render函数。那么我们就可以利用此钩子去做一些优化的操作，例如我们都知道父组件渲染时会带着子组件一起渲染，但有的时候子组件的数据并没有发生变化但还是会带着被渲染一次，就造成了不必要的性能浪费，这个时候在shouldComponentUpdata中加一层判断的话就可以解决这个问题。（当然，在创建组件时如果将继承的Component改成PureComponent，可帮忙做上面的优化）

getDerivedStateFromProps
这是一个新增的钩子，此钩子的处罚比较频繁，当组件被传入值时，不管相不相等都会执行,数据更新时也会执行(不管自身还是父组件传来的)

this.forceupdate()
强制渲染

getSnapshotBeforeUpdate
在DOM渲染之前获得一个快照

## 50、从启动webpack构建到输出结果经历了一系列过程，它们是什么 

1. 解析webpack配置参数，合并从shell传入和webpack.config.js文件里配置的参数，生产最后的配置结果。
2. 注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。
3. 从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。
4. 在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。
5. 递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。
6. 输出所有chunk到文件系统。

## 51、vue react  怎么检测数据变化的 

**Vue**
vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调

**React**

react状态变化只能通过setState,调用setState就会更新状态重新渲染dom

## 52、instanceof 的原理是什么？ 

实际上这里我们可以自己去手写一个Instanceof去分析

```
function myInstanceof(left, right) {
  let prototype = right.prototype
  left = left.__proto__
  while (true) {
    if (left === null || left === undefined)
      return false
    if (prototype === left)
      return true
    left = left.__proto__
  }
}
1234567891011
```

**上述代码思路：**
首先获取类型的原型
然后获得对象的原型
然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null

## 53、React中怎么让setState同步更新？ 

回调，promise,async+await

**回调**
setState函数的第二个参数允许传入回调函数，在状态更新完毕后进行调用，例如下面的这个例子

```
this.setState({
      data: '666'
    }, () => {
      console.log('加载完成')
    });

123456
```

**promise**
利用promise的特性，可以使用promise封装一个函数去一劳永逸的解决这个问题

```
setStateAsync(state) {
    return new Promise((resolve) => {
      this.setState(state, resolve)
    });
  }
12345
```

**async+await**
相当于promise的优雅版，我们可以利用await"等一等"的特性去让程序等待await后面的函数做完以后再执行下面的代码(当然，await必须要配合async使用),例如下面的小例子

```
async myfun(){
await this.setState({
   data: '666'
});
}
```

## 54、什么是immutable, 为什么要使用它 

什么是 Immutable Data
1.Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象
2.Immutable 实现的原理是 Persistent Data Structure （持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变

TIP:当然，通过这一点，我们可以去做时间旅行，也就是调用之前存在过的旧数据。

3.同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗， Immutable 使用了 Structural Sharing···· （结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。

## 55.什么是BFC，介绍一下BFC的触发方式以及特性

BFC(Block formatting Context) ，即块级格式化上下文，只要具备以下的某一个条件才可以成为BFC

### 1、BFC的触发条件

1、根元素  html标签就是一个bfc             

2、float的值不为none             

3、overflow的值不为visible             

4、display的值为 inline-block/ table-cell/ table-caption/ flex/ inline-flex           

5、position的值为absolute或fixed

### 2、 BFC特性

1、Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻box的margin会发生重叠（应用：可以解释为什么margin上下回重叠，以及解决方法的原因）

2、计算BFC的高度时，浮动元素也参与计算（应用：可以解释为什么高度塌陷可以用overflow：hidden等方法解决）

3、BFC的区域不会与float box发生重叠（应用：自适应两栏布局或者三栏布局<圣杯布局和双飞翼布局>）

4、BFC内部的Box会在垂直方向，一个接一个的放置。

5、每个元素的margin box的左边会与包含块border box的左边相接触（对于从左到右的格式化，否则相反），即使存在浮动也会如此。

6、BFC就是页面上的一个独立容器，容器里面的元素不会影响到外面的元素

## 56、介绍一下单页面和多页面的区别 

单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。

多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新

### 单页面的优点：

1，用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小

2，前后端分离

3，页面效果会比较炫酷（比如切换页面内容时的专场动画）

### 单页面缺点：

1，导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）

2，初次加载时耗时多

3，页面复杂度提高很多

## 57、介绍一下Vue中父子组件生命周期的执行顺序 

- 加载渲染过程

父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

- 子组件更新过程

父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

- 父组件更新过程

父 beforeUpdate -> 父 updated

- 销毁过程

父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed

## 58、Vue父子组件的通信方式有哪些

Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信

（1）props / $emit  适用 父子组件通信

- 这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。

（2）ref 与 parent / children 适用 父子组件通信

- ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例
- parent/children：访问父 / 子实例

（3）EventBus （emit / on）适用于父子、隔代、兄弟组件通信

- 这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。

（4）attrs / listeners 适用于 隔代组件通信

- attrs：包含了父作用域中不被prop所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind="$attrs" 传入内部组件。通常配合 inheritAttrs 选项一起使用。
- listeners：包含了父作用域中的 (不含 .native 修饰器的)  v-on 事件监听器。它可以通过 v-on="$listeners" 传入内部组件

（5）provide / inject 适用于 隔代组件通信

- 祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。

（6）Vuex  适用于 父子、隔代、兄弟组件通信

- Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。
- Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。

## 59、Vue中响应式的原理 

Vue的响应式原理也就是数据的双向绑定原理，数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。

Vue 主要通过以下 4 个步骤来实现数据双向绑定的：

- 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。
- 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。
- 实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。
- 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。

## 60、 虚拟DOM为什么会提高性能

虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。
用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把  所记录的差异应用到所构建的真正的 DOM 树上，视图就更新了。

## 61、vue中 computed 的原理

在具体讲computed之前，我们需要先知道几个知识点：

Vue.js 的核心包括一套“响应式系统”。
Vue 的响应式，核心机制是 观察者模式。
数据是被观察的一方，发生改变时，通知所有的观察者，这样观察者可以做出响应，比如，重新渲染然后更新视图。
Dep ：每个属性都拥有自己的消息订阅器dep，用于存放所有订阅了该属性的观察者对象。
dep 的属性：
id ：唯一的标识符
subs ：存放订阅者 watcher 的数组
Computed -> 惰性求值的观察者，具有缓存性，当依赖发生变化后，第一次访问 computed 属性，才会计算新的属性，并将该属性挂载到 vm （Vue实例）上

##### 原理分析

当组件初始化的时候，computed 和 data 会分别建立各自的响应系统，Observer遍历 data 中每个属性，使用 Object.defineProperty 的 get/set 方法对其进行数据劫持
初始化 computed 会调用 initComputed 函数
new 一个 watcher 实例，watcher 中实例化一个 Dep (消息订阅器) 收集依赖
data -> Dep -> watcher ，通过dep在data和watcher之间建立了依赖
创建的时候不会触发 get 方法
调用 computed 时会触发其 Object.defineProperty 的 get 访问器函数
dirty = true 会调用 watcher.get 方法重新计算，随后 dirty = false
启动依赖收集，调用 watcher.depend() 方法向自身的消息订阅器 dep.subs 中添加订阅者（其他属性的watcher）
当某个属性（依赖项）发生变化，触发 set 拦截函数，然后调用自身消息订阅器dep， dep 通过 notify 遍历当前 dep.subs 通知每个 watcher 更新（watcher.update()）。

## 62、webpack 优化有哪些

减少 Webpack 打包时间
优化 Loader （原因：Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。）

 优化 Loader 的文件搜索范围

​	module.exports = {
​	  module: {
​	    rules: [
​	      {
​	        // js 文件才使用 babel
​	        test: /\.js$/,
​	        loader: 'babel-loader',
​	        // 只在 src 文件夹下查找
​	        include: [resolve('src')],
​	        // 不会去查找的路径
​	        exclude: /node_modules/
​	      }
​	    ]
​	  }
​	}
将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间

loader: 'babel-loader?cacheDirectory=true'

HappyPack (Node是单线程，webpack打包也是单线程)

 HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了

代码压缩
（举例 js）
webpack3 ：webpack-parallel-uglify-plugin 来并行运行 UglifyJS
webpack4 ：mode 设置为 production 就可以默认开启以上功能

DllPlugin
DllPlugin 可以将特定的类库提前打包然后引入。
减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。

resolve.alias：通过别名来映射路径，能让 Webpack 更快找到路径

module.noParse：当确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助

externals
想引用一个库，但是不想让webpack打包，且不影响我们在程序中以CMD、AMD或者window/global全局等方式进行使用，那就可以通过配置externals。

resolve.extensions
import 时最好写扩展名
如果你导入的文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面。

减少 Webpack 打包后的文件体积
懒加载、按需加载
使用按需加载，将每个路由页面单独打包为一个文件；
也可以对大型类库使用按需加载
Scope Hoisting
Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。
Tree Shaking
移除 JavaScript 上下文中的未引用代码(dead-code)
Webpack 4 ：mode 设置为 production 会自动启动这个优化功能。

## 63、跨域的解决方案

1.jsonp
动态创建scipt,再清求一个带参网址实现跨域通信（script 标签的 src 属性不受同源策略的限制 ）；
jQuery ajax;
jsonp缺点:只能实现 get 一种请求。

2.跨域资源共享(CORS)
后端添加允许的请求头

```
// 配置 cors 跨域
	header("Access-Control-Allow-Origin:*");
	header("Access-Control-Request-Methods:GET, POST, PUT, DELETE, OPTIONS");
	header('Access-Control-Allow-Headers:x-requested-with,content-type,test-token,test-sessid');
```

3.nginx代理
实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。
nginx具体配置：

```
#proxy服务器
	server {
	    listen       81;
	    server_name  www.domain1.com;
	
	    location / {
	        proxy_pass   http://www.domain2.com:8080;  #反向代理
	        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
	        index  index.html index.htm;
	
	        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
	        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
	        add_header Access-Control-Allow-Credentials true;
	    }
	}
```

4.nodejs中间件代理
node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发
使用node + express + http-proxy-middleware搭建一个proxy服务器。
5.WebSocket协议
WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。
原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。
6.postMessage跨域
window属性的postMessage（HTML5 XMLHttpRequest Level 2中的API）
postMessage(data,origin)
7.document.domain + iframe跨域
仅限主域相同，子域不同的跨域应用场景。
实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。
8.location.hash + iframe
a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。
9.window.name + iframe跨域
name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。

## 64、React的diff算法，规则是什么？

React Diff 算法的差异查找实质是对两个JavaScript对象（虚拟DOM和真实DOM）的差异查找，所以React更新阶段才会有Diff算法的运用。
规则：

Web UI中 DOM 节点跨层级的移动操作特别少，可以忽略不计
拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构
对于同一层级的一组子节点，它们可以通过唯一的 id 进行区分

## 65、为什么不建议在 componentWillMount 做Ajax等操作？

一个组件的 componentWillMount 比 componentDidMount 也早调用不了几微秒，性能没啥提高；而且，等到异步渲染开启的时候，componentWillMount 就可能被中途打断，中断之后渲染又要重做一遍（例如：在 componentWillMount 中做 AJAX 调用，代码里看到只有调用一次，但是实际上可能调用 N 多次，这明显不合适）。相反，若把 AJAX 放在 componentDidMount，因为 componentDidMount 在第二阶段，所以绝对不会多次重复调用，这才是 AJAX 合适的位置。 

##  66、介绍React hooks

hooks是react 16.8引入的特性，他允许你在不写 class 的情况下操作 state 和 react 的其他特性。
hook s只是多了一种写组件的方法，使编写一个组件更简单更方便，同时可以自定义hook把公共的逻辑提取出来，让逻辑在多个组件之间共享。
在编写函数组件并意识到需要向其添加一些state 时，就可以使用hook。

hook的钩子：

- useState() 保存组件状态
- useEffect() 处理副作用
- useContext() 获取context的值，减少组件层级
- useReducer() 跟 redux 中的数据流的概念非常接近
- useCallback 记忆函数
- useRef 表示可以定义一个变量, 在函数体内实现唯一的引用
- useMemo() 主要用于渲染过程优化，两个参数依次是计算函数（通常是组件函数）和依赖状态列表，当依赖的状态发生改变时，才会触发计算函数的执行。如果没有指定依赖，则每一次渲染过程都会执行该计算函数。

React Hooks 提供为状态管理提供了新的可能性，尽管我们可能需要额外去维护一些内部的状态，但是可以避免通过 renderProps / HOC 等复杂的方式来处理状态管理的问题。Hooks 带来的好处如下：

- 更细粒度的代码复用，并且不会产生过多的副作用
- 函数式编程风格，代码更简洁，同时降低了使用和理解门槛
- 减少组件嵌套层数
- 组件数据流向更清晰

##  67、单行或多行文本溢出展示省略号的实现方法

## css 实现

1. 单行文本

   固定容器宽度

   white-space：nowrap

   work-break:keep-all

   overflow:hidden

   text-overflow:ellipsis

2.  多行文本

   添加line-clamp属性

   转成弹性布局

### js

多行文本检测子容器和父容器的高度，子容器高度超过父容器时，对子容器的字符串内容进行遍历，配合slice对子容器的高度进行重新更改，当新的容器高度高于父元素高度时，截取最后两个字符并且替换成,"…"

```
#container {
  border: 1px solid;
  height: 90px; 
  width: 30px; // height 和 width 都必要
  /*overflow: hidden;*/
  overflow-wrap: break-word; // 设置文本溢出容器宽度时换行（但会溢出容器长度）
}
#content {
  line-height: 30px; // 必要，控制文本行数。否则文本会被挤压，行数不定
}

var $container = $('#container')
var $content = $('#container .content')
var str = $content.text()
if ($content.height() > $container.height()) {
  for (var i = 0; i <= str.length; i++) {
    $content.text(str.slice(0,i))
    if ($content.height() > $container.height()) {
      $content.text(str.slice(0,i-2) + "..");
      break;
    }
  }
}
```

## 68、你知道ES6中的Generator和yiled吗，在实际开发中有使用过吗

Generator的初衷是用来解决异步的嵌套问题

语法: 使用 * 声明一个函数，这个函数在调用时会返回一个Generator对象，使用 * 声明的函数内部使用yield生成阻塞行为，yield后面声明的内容，配合一个外部调用的next方法来控制被阻塞代码的执行，并且yiled会将Generator中的value值设置成为刚刚被阻塞的内容的返回值，一个yiled配合一个next使用。

 所以在使用时通常可以将异步处理放在yiled后生成一个阻塞，配合一个返回值是promise的函数进行异步处理操作，需要使用两次的next，第一次是调用yiled后的函数，第二次是获得异步操作的结果

 实际应用:redux中间件的saga中takeEvery内部封装了这两部操作，两步并作一步直接让开发者拿到结果

## 69、redux处理的中间件有什么作用，使用过哪些redux处理的中间件？有什么优缺点

redux是相当于一个仓库，配合react使用时能够成为一种状态管理工具，但是redux本身的特性规定其在派发信息时只能派发同步并且是扁平化的内容，这样在redux中若想实现异步操作就会有很大的局限性，中间件等同于一个仓库管理员的身份，每次想去仓库中取货，必须经过管理员去取钥匙，redux-thunk，redux-saga是两个常用的中间件，通过中间件能够增强redux本身的功能，redux-thunk中能够处理函数，其内部机制就是识别派发的参数类型，若是函数则直接调用，若是对象直接进行派发的操作，redux-saga则在内部封装了一些方法能够拦截派发的请求，到内部执行异步操作后，再去处理数据。

redux-thunk直接函数，较为直接，但是由于派发内容可以是扁平的对象，也可以是函数，所以不易于维护。

redux-saga仍旧派发扁平对象，符合redux派发规则，但是实现的逻辑较为复杂，其实就是在内部封装了处理异步的行为。

## 70、如何在react中构建一个弹出的遮罩层

实现方式:

1. 组件库
   直接使用antdesign组件库中的遮罩层
2. react portal
   portal是ReactDOM上的一个方法，能够更改某组件或节点的挂载位置
   我们在需要构建弹出层的时候，将某个元素利用portal直接提升到与根组件并列的位置上，加一些覆盖的样式，就能够实现一个弹出层

```
 ReactDOM.createPortal(
 	<myComponent></myComponent>,// 更改位置的节点
 	document.queryselector("#root")// 挂载位置
 )
1234
```

为了便于复用，我们可以将portal封装在一个高阶组件或者装饰器中

```
import React from 'react'
import ReactDOM from 'react-dom'

function withModel (WrapperedComponent) {
 return class extends React.Component {
   render() {
     return (
       ReactDOM.createPortal(
         <WrapperedComponent {...this.props}></WrapperedComponent>,
         document.querySelector('body')
       )
     )
   }
 }
}

export default withModel
```

## 71、简述微信支付的业务流程

微信支付存在两种模式的实现，其中第二种模式较为简洁且易于实现 基本逻辑: 首先，用户需要在开发者的系统中下单，完成下单行为后向开发者的服务器发送请求，这个请求能够携带商品信息等数据，在服务器接收到请求时，需要向微信服务器发送请求，以完成一个预支付的行为，在发送请求前需要按照微信服务器的规则生成一些必要的参数，微信服务器在接收到请求时，会对签名进行验证，随后会返回一个支付url，开发者服务器需要将连接处理成为二维码供用户扫码支付 之后，用户在扫码后微信服务器会验证连接真实性及有效性，在完成支付行为后，微信服务器会以一种异步的形式，向开发者服务器发送请求，以通知开发者服务器支付状态，方便开发者执行后续操作。 

## 72、简单描述一下装饰器

装饰器是ES6中一种增强类的功能函数，基本实现就是传入一个类，在修饰器加工后返回一个具有修饰器中功能的新的类，常用在react中，类似于高阶组件的实现，但时没有了高阶组件的嵌套结构，语法上清晰明了
但是在webpack环境中如果使用修饰器，需要另外载入一些解析修饰器语法的babel

```
    "@babel/core": "^7.10.5",
    "@babel/preset-env": "^7.10.4",
    "@babel/plugin-proposal-decorators": "^7.10.5"
```

## 73、浏览器是怎样解析CSS选择器的？

CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。 

## 74、setTimeout、Promise、Async/Await 的区别?

事件循环中分为宏任务队列和微任务队列 其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行async函数表示函数里面可能会有异步方法，await后面跟一个表达式 async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行 

## 75、.call 和 .apply 区别是啥？

.call和.apply均用于调用函数，并且第一个参数将用作函数中this的值。但是，.call将逗号分隔的参数作为下一个参数，而.apply将参数数组作为下一个参数。简单记忆法：C用于call和逗号分隔，A用于apply和参数数组。 

## 76、HTML5 应用程序缓存和浏览器缓存有什么区别？

1. 应用程序缓存是 HTML5 的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如 HTML、CSS、图片以及 JavaScript。这个特性可以提高网站性能，它的实现借助于 manifest 文件，如下：

```
<!doctype html>
<html manifest=”example.appcache”>
…..
</html>

1234
```

与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。

## 77、什么是柯里化，并说明柯里化的好处？

柯里化是一种模式，其中一个具有多个参数的函数被分解成多个函数，当被串联调用时，这些函数将一次累加一个所需的所有参数。这种技术有助于使用函数式编写的代码更容易阅读和编写。需要注意的是，要实现一个函数，它需要从一个函数开始，然后分解成一系列函数，每个函数接受一个参数。 

## 78、简述微信小程序的原理？

微信小程序采用 JavaScript、WXML、WXSS 三种技术进行开发,本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口 微信的架构，是数据驱动的架构模式，它的 UI 和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现 小程序分为两个部分 webview 和 appService 。其中 webview 主要用来展现 UI ，appService 有来处理业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层 JSBridge 实现通信，实现 UI 的渲染、事件的处理 

## 79、git 怎么删除远程和本地分支 



## 80、闭包是什么？闭包的 this 指向？ 

## 81、React Context 使用 

## 82、vue 中的 key 有什么作用？不加会怎样？ 

## 83、React 的路由懒加载怎么实现？

## 84、cookie storage 的区别 什么时候使用 

## 85、vue的常用修饰符 

## 86、讲一下函数节流和防抖 

## 87、 map, filter, reduce 各自有什么作用？ 

## 88、JS的基本数据类型的判断方法有哪些？ 

## 89、Vue计算属性和Watch的区别 

## 90、React state 和 props 有什么不同 

## 1、构造函数,实例,原型对象三者的关系

每一个构造函数都会有一个原型对象，通过构造函数的prototype指向原型对象
原型对象里也有一个属性叫做constructor ，它又重新指回了构造函数
这是构造函数和原型对象之间的相互关系

我们可以通过构造函数来创建一个实例对象 ，只要我们new了构造函数就可以产生一个实例对象，所以我们构造函数就可以指向实例对象 ，实例对象里面也有一个原型为__proto__ ，这个__proto__指向原型对象 ,并且__proto__里也有一个constructor指向构造函数，这个指回构造函数是因为实例对象的__proto__指向原型对象，原型对象的constructor可以指回构造函数，所以实例对象的constructor可以通过原型对象指回构造函数

## 2、xss、csrf的攻击和预防

#### xss 全称跨站脚本攻击

XSS攻击的原理就是 攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等） ， 当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等

**预防**

1、将httpOnly属性设置为true，这样使用js 就获取不到cookie了

2、只允许用户输入我们期望的数据，我们可以对输入数据进行验证

3、对发送的数据进行编码转义处理，或者使用正则替换

4、服务端也要做判断处理查看是否有XSS攻击，然后做转义处理；

#### csrf 跨站请求伪造

顾名思义就是伪造请求，冒充用户在站内的正常操作。攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来讲，这个请求是完全合法的，但是却完成了攻击者所期望的一个操作。而且你自己还不知道究竟是哪些操作。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账…造成的问题包括：个人隐私泄露以及财产安全。

**CSRF攻击原理如下：**

1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
2. 此时用户登录网站A成功，可以正常发送请求到网站A
3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
4. 网站B返回一些攻击性代码，并发出一个请求要求访问网站A；
5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。

**预防**

1 尽量使用POST接口，限制GET接口

GET接口太容易被拿来做CSRF攻击，只要构造一个链接，便可以进行CSRF攻击。接口最好限制为POST使用，降低攻击风险。

当然POST并不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性

2 加入验证码

我们知道攻击者构造的就是一个伪请求,所以我们在提交的时候让用户去输入一下验证码或者是一些滑动验证码,这样能够确保这个行为是一个用户行为而非黑客行为,一般而言,简单的验证码也可能被破解的,但是一些智能地验证码还是很难被破解的

3 验证referer

我们知道在http协议的头部有一个字段叫referer,它能够记录当前一次请求的来源地址.如果黑客要对当前网站实施csrf的攻击,他只能在自己的网站构造请求,所以referer传过来的是和当前网站不同的域名,我们可以在后端判断一下,如果referer值不是当前的网站,那么直接就拒绝这个请求

4 使用token

在用户登录成功后，返回一个随机token给浏览器，当每次用户发送请求的时候，将token 主动发送给服务器端（为了安全，不建议将token以参数的形式传给服务器，可以将token存储在请求头中），服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

## 3、混合开发的原理

h5通过window.location.href发起一个自定义的get请求，原生拦截到我们h5发送到的自定义请求然后做相应的处理，之后在webview中注入一段js代码，这段js代码会执行h5的js代码并且会传递数据给h5，这样就完成了一次h5和原生混合开发的过程

**具体的实现流程是**

首先，当一个h5需要调用原生的功能的话，比如h5需要调用原生的拍照功能，这时候h5就可以写一个 方法，然后传入三个参数，分别是标识，成功的回调和失败的回调，这个标识就是和原生协议好的一个字符串，原生可以根据这个字符串调用相对应的功能

h5操作
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200812103946710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1Nzk2NA==,size_16,color_FFFFFF,t_70#pic_center)然后h5在这个方法中使用window.location.href发起一个自定义的get请求，这个请求使用的是自定义的协议，这个自定义的协议也是和原生商量好的一个字段，原生可以根据这个自定义协议拦截到h5发送过来的请求，然后可以做相应的原生操作，比如根据自定义的标识调用原生调取相机的方法

并且h5要把原生需要回调的方法写在全局中，这样原生就可以调用了（见下面详解）

h5
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200812105234214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1Nzk2NA==,size_16,color_FFFFFF,t_70#pic_center)

原生
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200812104434940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1Nzk2NA==,size_16,color_FFFFFF,t_70#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020081210464955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1Nzk2NA==,size_16,color_FFFFFF,t_70#pic_center)
最后原生把一段js代码注入到webview之中，这段js代码就是用于调用h5的js代码的，并且把返回数据携带给h5，这段js代码是由h5提供的，但是如果要调用这个方法的话，h5必须把这个方法定义在全局中，这样原生才可以调用（见第二张图）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200812104925877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1Nzk2NA==,size_16,color_FFFFFF,t_70#pic_center)

## 4、 v-on可以绑定多个方法吗

如果需要绑定多个不同类型的事件的话，可以以对象的键值对形式，比如在v-on上绑定一个click和mouseover事件，我们可以使用`v-on=“{click:方法名，mouseover：方法名}”`

如果需要绑定多个相同类型的事件的话，直接以逗号分隔方法名，比如绑定click事件，我们可以写`@click="方法1，方法2"`

## 5、 客户端渲染和服务端渲染的区别

**客户端渲染和服务端渲染**

服务器端通过页面模板和数据生成HTML页面，返回给 客户端完整的html，这样浏览器就可以直接显示了

客户端渲染：后端提供一些api使得前端可以获取json数据，然后前端拿到json数据之后再在前端进行html页面拼接，然后展示在浏览器上

**两者本质区别**

客户端渲染和服务器端渲染的最重要的区别就是究竟是谁来完成html文件的完整拼接

**优缺点分析**

客户端：

优点：客户端渲染的优点就是网络传输的数据量比较小，减少了服务端的压力，前后端分离，前后端人员可以分工合作，代码耦合度低，并且前端人员可以有更多的选择性，比如使用单页面，可以有更好的用户体验，

缺点：就是不利于seo的优化，首次加载可能会比较慢，因为要加载很多js，css文件

服务端：

优点：不占用前端的资源 ，页面渲染快，并且有利于seo的优化

缺点：前后端不分离，开发时的耦合度很高，分工不明确，降低开发效率，用户量大的时候，对服务器的负荷也会增大

## 6、 类组件和函数组件有什么区别

**类组件**可以使用其他特性，如状态 `state` 和生命周期钩子。

当组件只是接收 `props` 渲染到页面时，就是无状态组件，就属于函数组件

函数组件的性能比类组件的性能要高， 因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。

函数组件没有this,没有生命周期，没有状态state,

类组件有this,有生命周期，有状态state。

## 7、什么是高阶组件、受控组件、非受控组件？

**高阶组件**
是个函数，输出结果是个新组件，可以对输入的组件进行加工，并返回一个具有特定功能的组件。
**受控组件**
相当于input中的value值通过state值获取，onChange事件改变state中的value值。实现了双向绑定，任意一方的数据发生变化，另一方也会随之改变 。
**非受控组件**
不需要设置对应的state属性，可通过ref来直接操作真实的dom。

## 8、vuex和redux的区别

表面区别就是vuex是通过将store注入到组件实例中，通过dispatch和commit来维护state的状态，并可以通过mapstate和this.$store来读取state数据。而redux则是需要通过connect将state和dispatch连接来映射state并操作state。redux没有commit，直接通过dispatch派发一个action来维护state的数据。并且只能通过reducer一个函数来操作state。
rudex使用的是不可变数据；vuex是可变的数据。
rudex每次都是返回一个新的state；而vuex是直接改变state。

## 9、http的缓存机制

关于HTTP的缓存机制来说，这些缓存策略都会体现在HTTP的头部信息的字段上，这些策略会根据是否需要重新向服务器发起请求可以分为强缓存和协商缓存两大类。
**强缓存：** 请求某个资源文件时，服务端就会在response
header中对该资源文件做缓存配置：cache-control，常见的设置是max-age public private
no-cache no-store immutable等。当用户打开某页面，浏览器会判断缓存是否过期，没有过期就会从缓存中读取数据。
**协商缓存：** 协商缓存就是需要客户端和服务器两端进行交互的；每次请求回来的response
header中的etag和last-modified；下次请求带上，服务端会进行标识和对比，如果资源更新了就会返回新的资源和对应的etag和last-modified；反之资源没有变。

## 10、什么是数组扁平化，实现扁平化的方法有哪些？

数组扁平化，就是将一个复杂的嵌套多层的数组，一层一层的转化为层级较少或者只有一层数组。
arr.flat(Infinity)
底层原理：通过foreach遍历和递归的方式进行一层一层的遍历。
arr.toString.split(“,”)
reduce和递归来实现
foreach遍历和递归

## 11、什么是回流和重绘

回流：当rendertree的一部分或者全部元素因改变了自身的宽高，布局，显示或隐藏，或元素内部的文字结构发生变化,导致需要重新构建页面的时候，回流就产生了。
重绘: 当一个元素自身的宽高，布局，及显示或隐藏没有改变，而只是改变了元素的外观风格的时候，就产生了重绘。
结论：回流必定触发重绘，而重绘不一定触发回流。

## 12、webpack中在使用babel插件处理js代码的时候，为什么使用polyfill，如何使用polyfill ？

因为在使用preset_env 处理js代码时，无法将所有的ES6的语法全部转换成ES5语法，就比如promise、array.from以及实例方法都无法转换，这个时候需要加入垫片。
在入口文件引入@babel/polyfill ，会污染全局环境
在配置文件中的entry中写 ，也会污染全局环境
可以配置@babel/preset-env useBuiltIns接收3个参数
entry：不管代码 有没有用到，只要目标浏览器不支持的都会引入对应的polyfill；自动引入polyfill模块
usage: 根据代码的使用情况，按需引入；自动引入polyfill模块
false：不会自动引入polyfill模块
corejs 3.0以后的版本； 如果参数为entry，则需要在入口文件中引入两个包

## 13、map和forEach的区别？

map和forEach都是对数组的遍历，但是他们是有区别的，forEach()方法不会返回执行结果，而是undefined。也就是说，forEach()会修改原来的数组。而map()方法会得到一个新的数组并返回。

例如，在react经常需要使用数据进行渲染元素的时候，那么这时候，我们就需要使用map了,返回一个新的元素的数组进行渲染。而forEach就是不需要返回新的数据，需要在原数组的每一项上修改的时候，我们经常会用到。

## 14、redux的工作流程？

简明来说，首先创建一个store分别管理相应的reducer,在组件内部派发action之后，看是否需要中间件进行处理，如果是ajax等异步操作，可以放入thunk或者saga等中间件，进行处理之后然后传到reducer之中，如果组件里面需要数据,可以通过connect高阶组件或者getState()获取reducer里面的数据。

## 15、容器组件和UI组件的区别

容器组件里面有逻辑操作，可以提供数据和行为给UI组件，并且容器组件时有状态的
UI组件时无状态的，只可以通过props去接受数据，主要用来展示组件内容，是无状态的

## 16、react中context的使用？

context，通过createContext创建一个context，在所有组件的最外层包裹一个provider,然后通过给provider绑定数据以及方法，然后后代组件可以通过tatic contextType 或者consumer来获取context里面的值，如果是consumer的话，那么就是使用一个回调函数，回调函数的参数就是context的值

## 17、React路由加载的几种方式？

路由组件的加载一共有三种方式，component\render\children
component可以直接引入组件名，也可以通过一个回调函数去引入一个组件
render只可以通过回调函数引入组件
children和render一样也是通过一个回调函数组件，但是children引入的组件，无论路径是否匹配都显示引入的组件，最后通过match对象的match属性去对应相应的路由，常用于高亮效果等！

## 18、提供网页加载速度的方式？（优化）

1、首先可以减少http的请求
2、首页可以使用服务端渲染
3、懒加载图片
4、添加Expires请求头，缓存http访问的组件，下次访问的时候减少不必要的http请求，提高加载速度。
5、使用CDN，减小服务器负担
6、启用GZIP压缩，压缩必要资源，从而给用户发送最小的HTML文件和CSS/JS等资源

## 19、div+css 的布局较 table 布局有什么优点？

改版的时候更方便 只要改 css 文件。
页面加载速度更快、结构化清晰、页面显示简洁。
表现与结构相分离。
易于优化（seo）搜索引擎更友好，排名更容易靠前。

a> div+css布局的好处：
1.符合W3C标准，代码结构清晰明了，结构、样式和行为分离，带来足够好的可维护性。
2.布局精准，网站版面布局修改简单。
3.加快了页面的加载速度（最重要的）。
4.节约站点所占的空间和站点的流量。
5.用只包含结构化内容的HTML代替嵌套的标签，提高另外搜索引擎对网页的搜索效率。
b> table布局的好处（table布局也不是一点用的没有，这点是毋庸置疑的）
1.容易上手。
2.可以形成复杂的变化，简单快速。
3.表现上更加“严谨”，在不同浏览器中都能得到很好的兼容。

## 20、vue路由懒加载方式；

方法一 resolve
这一种方法较常见。它主要是使用了resolve的异步机制，用require代替了import,实现按需加载

方法二 官网方法
vue-router在官网提供了一种方法，可以理解也是为通过Promise的resolve机制。因为Promise函数返回的Promise为resolve组件本身，而我们又可以使用import来导入组件。

方法三 require.ensure
这种模式可以通过参数中的webpackChunkName将js分开打包。
component: resolve => require.ensure([], () => resolve(require(’@/components/’+componentName)), ‘webpackChunkName’)

结合 Vue 的异步组件和 Webpack 的代码分割功能，把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件

## 21、redux工作流程；

首先，用户发出 Action。然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。State 一旦有变化，Store 就会调用监听函数。listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。

## 22、Es6 module和commonjs的区别；

CommonJS和ES6 Module是目前使用较为广泛的模块标准。它们的主要区别在于
1.前者建立模块依赖关系是在运行时，后者是在编译时；
2.在模块导入方面，CommonJS导入的是值拷贝，ES6 Module导入的是只读的变量映射；
3.ES6 Module通过其静态特性可以进行编译过程中的优化，并且具备处理循环依赖的能力。

## 23、hash、chunkhash、contenthash三者区别

一、hash（所有文件哈希值相同，只要改变内容跟之前的不一致，所有哈希值都改变，没有做到缓存意义）
二、chunkhash（同一个模块，就算将js和css分离，其哈希值也是相同的，修改一处，js和css哈希值都会变，同hash，没有做到缓存意义）
三、contenthash（只要文件内容不一样，产生的哈希值就不一样）

## 24、React 中 keys 的作用是什么？

Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。
在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。

## 25、React 新老版生命周期函数

老版生命周期函数：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200813164526156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1Nzk2NA==,size_16,color_FFFFFF,t_70#pic_center)

新版生命周期函数：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200813164536264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1Nzk2NA==,size_16,color_FFFFFF,t_70#pic_center)

`Render`函数靠mouting时触发，如果在里面调用状态会造成死循环
`componentWillMount` 相当于vue中的beforemount,在dom渲染之前触发的

`componentDidMount` 在dom渲染完之后，是一个创建时期调用的钩子

`componentWillReceiveProps(props.state)` 检测父组件给的信息，一有变化就会run

`componentWillUnmount` 在组件被卸载时调用

`shouldComponentUpdata` 此钩子新老版生命周期函数中都存在，主要用于在渲染之前，判断是否执行渲染，相当于一个开关，当执行结果为false时不会触发后面的render函数。那么我们就可以利用此钩子去做一些优化的操作，例如我们都知道父组件渲染时会带着子组件一起渲染，但有的时候子组件的数据并没有发生变化但还是会带着被渲染一次，就造成了不必要的性能浪费，这个时候在shouldComponentUpdata中加一层判断的话就可以解决这个问题。（当然，在创建组件时如果将继承的Component改成PureComponent，可帮忙做上面的优化）

`getDerivedStateFromProps` 这是一个新增的钩子，此钩子的处罚比较频繁，当组件被传入值时，不管相不相等都会执行,数据更新时也会执行(不管自身还是父组件传来的)

`this.forceupdate()` 强制渲染

`getSnapshotBeforeUpdate`在DOM渲染之前获得一个快照

## 26、从启动webpack构建到输出结果经历了一系列过程，它们是什么

1. 解析webpack配置参数，合并从shell传入和webpack.config.js文件里配置的参数，生产最后的配置结果。
2. 注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。
3. 从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。
4. 在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。
5. 递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。
   输出所有chunk到文件系统。

## 27、vue react 怎么检测数据变化的

**Vue**
vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过`Object.defineProperty()`来劫持各个属性的`setter，getter`，在数据变动时发布消息给订阅者，触发相应的监听回调

**React**

react状态变化只能通过setState,调用setState就会更新状态重新渲染dom

## 28、instanceof 的原理是什么？

实际上这里我们可以自己去手写一个Instanceof去分析

```
function myInstanceof(left, right) {
  let prototype = right.prototype
  left = left.__proto__
  while (true) {
    if (left === null || left === undefined)
      return false
    if (prototype === left)
      return true
    left = left.__proto__
  }
}

123456789101112
```

**上述代码思路：**
首先获取类型的原型
然后获得对象的原型
然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null

## 29、React中怎么让setState同步更新？

回调，promise,async+await

**回调**
setState函数的第二个参数允许传入回调函数，在状态更新完毕后进行调用，例如下面的这个例子

```
this.setState({
      data: '666'
    }, () => {
      console.log('加载完成')
    });


1234567
```

**promise**
利用promise的特性，可以使用promise封装一个函数去一劳永逸的解决这个问题

```
setStateAsync(state) {
    return new Promise((resolve) => {
      this.setState(state, resolve)
    });
  }

123456
```

**async+await**
相当于promise的优雅版，我们可以利用await"等一等"的特性去让程序等待await后面的函数做完以后再执行下面的代码(当然，await必须要配合async使用),例如下面的小例子

```
async myfun(){
await this.setState({
   data: '666'
});
}



12345678
```

## 30、什么是immutable, 为什么要使用它

什么是 Immutable Data
1.Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象
2.Immutable 实现的原理是 Persistent Data Structure （持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变

TIP:当然，通过这一点，我们可以去做时间旅行，也就是以前调用之前存在过的旧数据。

3.同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗， Immutable 使用了 Structural Sharing···· （结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。

TIP:例如有下图的一个数据结构（灵魂画手就是我了）：

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020081316573313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1Nzk2NA==,size_16,color_FFFFFF,t_70#pic_center)
例如我们现在数据C2发生改变，那么他只会影响到B2与A，其他不会受到影响的数据直接复制过来就好了无需重新进行操作，性能有所提升。
关于具体的优缺点可以看下图
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200813165753637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1Nzk2NA==,size_16,color_FFFFFF,t_70#pic_center)

## 31、Vue 常用的修饰符

`.lazy`：v-model 在每次 input 事件触发的时候都会去进行数据同步，添加 lazy 修饰符后就转变为 change 事件触发时再进行数据同步。
`.number`：可以自动将用户输入的值转为数值类型
`.trim`：可以自动过滤用户输入的守卫空白字符
事件修饰符：

`.stop`：阻止冒泡， event.stopPropagation() 或 cancelBubble
`prevent`：拦截默认事件，等同于 event.preventDefault()
`.passive`：不拦截默认事件告诉浏览器，不用查询了，我们没用preventDefault阻止默认动作。与 prevent 冲突，不能同时使用。
`.capture`：事件在捕获阶段执行
`.self`：只会触发自身事件，不包含子元素的事件
`.once`：事件只会触发一次

## 32、函数节流和防抖

- **节流**：
  说白了就是减少执行频率，自定义一个时间间隔，如果多次去触发一个函数让这个函数每隔这个时间就执行一次，在时间间隔内触发这个方法的均无视。最常见的像scroll这种操作，没必要执行频率那么高，十分影响性能，搞个几百毫秒执行一次就够意思的了，当然具体执行时间间隔还得视业务需求而定
- **防抖**：
  说白了就是你还在操作我就不执行它，等你停下来我才执行。还是拿滚动scroll来说事，你监听了文档的scroll，但希望在滚动过程中不执行定义的方法，等停下来才执行，那就是典型的防抖

## 33、map，filter，reduce 各自有什么用

- **map**：就是遍历原数组，执行一些操作后放入新数组，最后返回新数组。有三个参数分别是，当前项、索引、原数组
- **filter**：过滤器，取出数组中符合要求的项放入新数组。在遍历数组的时候将返回值为 true 的元素放入新数组，我们可以利用这个函数删除一些不需要的元素。
- **reduce**：reduce 就是一个累加器，reduce 为数组的每一项都执行一次回调函数，我们可以对每一项都进行操作，可以接受四个参数分别是上一次回调返回的结果、当前项、当前索引，原数组。

map 为迭代器，通常用于处理数据结构的所有数据，并进行数据结构的重构；reduce 为累加器，虽然 reduce 也可以完成 map 的一些工作但是并不提倡这么做。

## 34、js 的基本数据类型判断方法

- **typeof**：
  其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 8 种：number、boolean、symbol、string、object、undefined、function、bigInt 等。
  但是 typeof 有一定的缺陷。typeof NaN 的返回值是 number，typeof [] 返回值是 object，typeof null 结果也是 object。所以用typeof除了string和boolean其他的都不太靠谱
- **instanceof**：
  一般用来判断引用数据类型的判断，比如 Object、Function、Array、Date、RegExp等等。实现原理主要就是判断右边变量的 prototype 在不在左边变量的原型链上，判断对象和构造函数在原型链上是否有关系，如果有关系，返回真，否则返回假。所以使用 instanceof 来判断类型的话只能知道是不是要判断的这个类型，如果不是就不能知道其准确的类型。
- **Object.prototype.toString.call**：
  toString 是 Object 原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString 运行时 this 指向的对象类型, 返回的类型格式为 [object,xxx]，xxx 是具体的数据类型，包括 String，Number，Boolean，Undefined，Null，Function，Date，Array，RegExp，Error，HTMLDocument…

## 35、 Vue 中 computed 和 watcher 的区别

**watcher** 顾名思义就是监听数据变化，它监听的数据来自 props、data、computed 的数据。他有两个参数分别是 newValue 和 oldValue。watcher 默认是浅监听，如果想要深度监听的话可以加一个deep:true;
**computed** 用于处理复杂的逻辑运算，比较适合对多个变量或者对象进行处理后返回一个结果值

computed 支持缓存，只有依赖数据发生改变，才会重新进行计算；watcher 不支持缓存，数据变，直接会触发相应的操作
computed 不支持异步，当computed内有异步操作时无效，无法监听数据的变化。watch 支持异步。

## 36、 React state 和 props 有什么不同

- **props** 是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的 props 来重新渲染子组件，否则子组件的 props 以及展现形式不会改变。
- **state** 是组件自身的状态，的主要作用是用于组件保存、控制以及修改自己的状态的一些数据，它只能在 constructor 中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的 this.setState 来修改，修改 state 属性会导致组件的重新渲染。

state 是组件自己管理数据，控制自己的状态，可变；
props 是外部传入的数据参数，不可变；

## 37、git 怎么删除远程和本地分支

删除本地分支：`git branch -D 分支名`
删除远程分支：`git branch origin -D 分支名`

## 38、 闭包是什么？闭包的 this 指向？

闭包是指有权访问另外一个函数作用域中的变量的函数。一般是在一个函数内返回一个函数，这个被返回的函数就是一个闭包函数。

this对象是在运行时基于函数的执行环境绑定的，谁调用this就是谁。一般的闭包我们调用第一层时是像全局返回一个函数，所以当再调用第二层时里边的this就是指向全局。

因为闭包并不属于这个对象的属性或方法。所以在闭包中的this是指向window的

## 39、 webpack 中 loader 和 plugin 的区别

- **loader** 用于加载某些资源文件。因为 webpaack 只能理解 JavaScript 和 JSON 文件，对于其他资源例如 css 、图片、jsx 、视频等等是没有办法加载的，就需要对应的 loader 将资源转化加载进来。字面意思三个可以看出，loader 适用于加载的，它作用域一个个文件上。
- **plugin** 用于拓展 webpack 的功能。针对是loader结束后，webpack打包的整个过程。它并不直接操作文件，而是基于事件机制工作。目的在于解决loader无法实现的其他事，从打包优化和压缩。

## 40、 vue 中的 key 有什么作用？不加会怎样？

key 就是给每个节点一个唯一的标识，key是给每一个vnode的唯一id,可以依靠key,更准确, 更快的拿到oldVnode中对应的vnode节点。
如果不加 key ，在更新的时候 vue 会去比较所有的项，然后把全部的元素进行替换，造成性能的降低。

## 41、React 的路由懒加载怎么实现？

使用传统的 import 的方式。可以在函数内 return 一个 import， 添加 webpackChunkName 的注释，这样 webpack 打包时就会将对应的文件单独打包，当函数执行时再去加载这个包。

```
return import( /* webpackChunkName: "lodash" */ 'lodash').then(_ => {}
1
```

使用 React.lazy 实现。导入时调用 React.lazy 并给他一个函数参数，函数中返回 import React.lazy(() => import("./XXX"))。配合 Suspense 可以实现在模块未加载完成的时候给用户一个提示。

## 42、cookie storage 的区别？什么时候使用

- cookie 数据始终携带在请求中，storage 不会主动的发送给服务器。
- cookie 数据一般限制为大小不超过 4k ，sessionStore 和 localStorage 虽然也有大小限制，但是比 cookie 大的多，可以达到 5M 或更大。
- 有效期不同，sessionStorage 仅在当前窗口关闭前有效，不能持久保存，localStorage 不会主动失效，可以保存持久数据。 cookie 在设置的过期时间之前一直有效
- 作用域不同。sessionStorage 在不同的窗口中是不共享的，即使是打开的同一个页面也不会共享。localStorage 对所有同源的窗口都是共享的。cookie 也是对同源的窗口共享

**使用场景：**

- cookie 比较小所以不会存大量的数据，一般当你有一些信息在每次请求中都需要携带的时候才会放到 cookie 比如登录信息、设置信息等。
- localStorage 一般用于前端缓存一些数据，这些数据只在前端使用不在后端使用，比如一些网站的编辑器自动保存草稿的功能就可以保存在 localStorage 中。

## 43、vue组件中data为什么必须是一个函数？

这是由于JavaScript的特性导致的，在`component`中，`data`必须是以函数的形式存在，不可以是对象。
在组件中的`data`写出一个函数，数据以**函数返回值**的形式定义，这样每次复用组件的时候，都会返回一份新的`data`，相当于每个组件实例都有自己私有的数据空间，他们只需要负责维护各自的数据，不会造成混乱。而单纯写成对象形式的话，就是所有的组件实例共用一个`data`，这样改一个全都改了。

## 44、请说下封装 `vue` 组件的过程？

1. 首先建立组件的模板，先把架子搭起来，然后考虑好组件的样式和基本逻辑结构。
2. 准备好组件的数据输入，即分析好逻辑，确定好 props里面的数据、类型
3. 准备好组件的数据输出，即根据组件逻辑，做好要暴露出来的方法
4. 封装完毕后，直接调用即可。

## 45、为什么使用React，React 有那些优势？

1. **React 速度很快**：它并不直接对DOM进行操作，而是引入一个叫做虚拟DOM的概念，安插在JavaScript逻辑和实际的DOM之间，所以性能比较好
2. **跨浏览器兼容**：虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至可以在IE8中使用
3. **一切都是component**：代码更加模块化，重用代码更容易，代码可维护性更高
4. **单向数据流**：Flux 是一个用于在 JavaScript 应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化
5. **同构、纯粹的JavaScript**：因为搜索引擎的爬虫程序依赖的是服务端响应，而不是JavaScript的执行，所以预渲染应用有助于搜索引擎的优化
6. **兼容性好**：比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。他们使得那些艰难的任务变得简单化。

## 46、说一下浏览器 cookie 和 session 的认识。

- session 是基于cookie实现的。
- cookie保存在客户端浏览器中，而session是保存在服务器上；
- cookie的机制是通过检查客户身上的通行证来确定用户的身份，session的机制就是通过检查服务器上的客户表来确定客户的身份；session相当于在服务器上建立一份客户档案，客户来访问的时候只需要通过查询客户表就可以了。

**cookie和session的区别：**

1. **存放的位置**：cookie是存在与客户端的临时文件夹中；session是存在于服务器的内存中，一个session域对象为一个用户浏览器服务。
2. **安全性**：cookie是以明文的方式存放在客户端上，安全性比较低，但是可以通过一个加密算法进行加密后存放；session是存放在服务器的内存中，所以安全性比较好。
3. **生命周期**：cookie的生命周期是通过设置有效时间来进行累计的，从创建开始计时，有效时间结束即cookie生命周期结束；session的生命周期是间隔的，从创建时开始计时，如果在有效时间内没有被访问，那么session的生命周期就会被销毁，但是如果在这个时间内访问过，那么将重新计算session的生命周期。关机会造成session生命周期的结束，但是对cookie没有影响。
4. **访问范围**：cookie为多个用户浏览器共享；session为一个用户浏览器独享。

## 47、DOM 事件有哪些阶段？谈谈对事件代理的理解？

- **DOM事件分为三大阶段：**
  - 捕获阶段（事件从Document节点自上而下向目标节点传播的阶段）
  - 目标阶段（真正的目标节点正在处理事件的阶段）
  - 冒泡阶段（事件从目标节点自下而上向Document节点传播的阶段）
- **事件代理** 简单来说就是：事件不直接绑定到某个元素上，而是绑定到该元素的父元素上，进行触发事件操作时，在通过条件进行判断，执行事件触发后的语句。
  - 事件代理的好处：（1）使代码更简洁；（2）节省内存开销；

## 48、你能描述一下渐进增强和优雅降级之间的不同吗?

- **渐进增强**：针对低版本浏览器进行构建页面，保证最基本的功能实现，然后再针对高版本浏览器进行效果、交互等改进和追加功能，达到更好的用户体验。
- **优雅降级**：是从一开始就构建一套完整的功能，然后在针对低版本浏览器进行兼容处理。

**区别：**

- 优雅降级是从复杂的现状开始，并试图减少用户体验的供给，意味着往回看；
- 而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要，意味着朝前看，同时保证其根基处于安全地带。

**其实使用这两种设计范例的人都有其各自的观点：**

- 渐进增强的观点认为应该关注内容的本身，不管建立网站的原因是什么，他们所有的相同点都是基于内容的，所以渐进增强成为一种更为合理的设计范例，这也是他被`yahoo`采纳并且构建的原因。
- 而优雅降级的观点认为应该针对那些最高级、最完善的浏览器来设计网站，那些被认为过时了的或者是有功能缺失的浏览器的测试工作应该安排在开发周期的最后阶段，并且把测试对象限定为主流浏览器的前一个版本。所以在这种设计范例下，旧版的浏览器就被认为仅能提供 “简陋却无妨” 的浏览体验。

## 49、构造函数,实例对象,原型对象三者的关系  

## 50.、前端开发JavaScript原理 ： 内存机制

JavaScript 具有自动垃圾收集机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。而在 C 和 C++ 之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问题的一个根源。

因为JavaScript具有自动垃圾收集机制，内存的分配与回收都完全实现了自动管理，所以一些前端开发工程师在开发时不关心内存的使用问题。

### **一.什么是内存？**

> 在硬件级别上，计算机内存由大量触发器组成。每个触发器包含几个晶体管，能够存储一个位。单个触发器可以通过唯一标识符寻址，因此我们可以读取和覆盖它们。因此，从概念上讲，我们可以把我们的整个计算机内存看作是一个巨大的位数组，我们可以读和写。

这么底层的概念，了解下就好，绝大多数数情况下，JavaScript 语言作为你们高级语言，无需使用二进制进直接进行读和写。

### **二.内存生命周期**

内存也是有**生命周期**的，不管什么程序语言，一般可以按顺序分为三个周期：

- 分配期：分配所需要的内存
- 使用期：使用分配到的内存（读、写）
- 释放期：不需要时将其释放和归还

内存分配 -> 内存使用 -> 内存释放。

![img](https://pic4.zhimg.com/80/v2-58644409ade3520720ee060aec885cb3_720w.jpg)

### 三.JavaScript内存的生命周期：

- 内存分配：分配你所需要的暂时使用内存大小，当申明变量、函数、对象的时候，系统会自动为他们分配内存
- 内存使用：即读写内存，在每次创建字变量、函数、对象的时候，程序会分配新内存来存储实体。
- 内存回收：对于不需要使用的内存将其释放。

各种语言都有自己的垃圾回收（garbage collection, 简称GC）机制，在释放内存这一步各种语言处理机制会有不同。做GC的第一步是判断堆中存的是数据还是指针，是指针的话，说明它被指向活跃的对象。对于JavaScript而言，最初的垃圾回收机制，是基于引用计次来做的。后来升级为标记清除。

为了便于理解，下面用一个简单的例子来解释JavaScript内存的生命周期。

```
var a = 50;  // 在内存中给数值变量分配空间
alert(a + 100);  // 使用内存
a = null; // 使用完毕之后，释放内存空间
```

第一步和第二步都很好理解，JavaScript在定义变量时就完成了内存分配。第三步释放内存空间则需要重点理解。
JavaScript有自动垃圾收集机制，就是找出那些不再继续使用的值，然后释放其占用的内存。最困难的工作在于计算出何时不再需要已分配的内存，这通常要求开发人员来决定在程序中哪些地方不再需要内存，并将其释放。

高级语言中嵌入了一种称为垃圾收集器的软件，它的工作是跟踪内存的分配和使用，以便在任何情况下找到一块不再需要的已分配内存，并自动将其释放。不幸的是，这个过程只是进行粗略估计，因为很难知道某块内存是否真的需要 (不能通过算法来解决)。垃圾收集器大多数的工作是收集无法访问的内存，例如，所有指向这块内存的变量都超出了作用域。但是，这些收集到的内存空间并不完整。因为在任何时候都可能存在这么一块内存：有一个变量指向了它，但它却永远不会被访问到。

### 四.垃圾回收的原理

实现垃圾回收的两种常见算法：**引用计数和标记清除**。

**A.引用计数**

引用计数（reference counting）：**当声明一个变量并将一个引用类型复制给该变量时，则这个值引用就加1，相反，如果包含这个值的变量又取得另外一个值，那么这个值的引用就减1，当引用次数变为0，则说明这个值不再用到了，这时就可以将这块内存释放。**

在语言引擎中有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是`0`，就表示这个值不再用到了，因此可以将这块内存释放。

![img](https://pic3.zhimg.com/80/v2-fd4f736663e705a1716c96d0441f02e6_720w.jpg)

上图中，左下角的两个值，没有任何引用，所以可以释放。如果一个值不再需要了，引用数却不为`0`，垃圾回收机制无法释放这块内存，从而导致内存泄漏。

引用计数就是跟踪对象被引用的次数，当一个对象的引用计数为0即没有其他对象引用它时，说明该对象已经无需访问了，因此就会回收其所占的内存，这样，当垃圾回收器下次运行就会释放引用数为0的对象所占用的内存。

> 但引用计数存在一个弊端就是循环引用问题（IE6和IE7就是采用此算法）。循环引用就是指对象A中包含一个指向对象B的引用，而对象B中也包含一个指向对象的引用。

```
function problem() {
var A = {};
var B = {};
A.a = B;
B.a = A;
}
```

上面例子可以看出对象A和B存在循环音引用的问题，即两个的引用次数均为2，它们在运行之后依然存在，并且引用次数永远不为0，如果这个函数被多次调用，就有可能引起内存泄漏问题。为了解决循环引用的问题，还有一种方法就是可以实现垃圾回收，那就是标记清除法。

**B.标记清除**

标记清除法是现代浏览器常用的一种垃圾收集方式，**当变量进入环境（即在一个函数中声明一个变量）时，就将此变量标记为“进入环境”，进入环境的变量是不能被释放，因为只有执行流进入相应的环境，就可能会引用它们。而当变量离开环境时，就标记为“离开环境”。**

垃圾收集器在运行时会给储存在内存中的所有变量加上标记，然后会去掉环境中的变量以及被环境中的变量引用的变量的标记，当执行完毕那些没有存在引用无法访问的变量就被加上标记，最后垃圾收集器完成清除工作，释放掉那些打上标记的变量所占的内存。

> 标记清除之所以不存在循环引用的问题，是因为当函数执行完毕之后，对象A和B就已经离开了所在的作用域，此时两个变量被标记为“离开环境”，等待被垃圾收集器回收，最后释放其内存。

### 五.JavaScript垃圾回收机制的意义

在不需要字符串、对象的时候，需要释放其所占用的内存，否则将会消耗完系统中所有可用的内存，造成系统崩溃

### **六.内存泄漏**

> 在计算机科学中，**内存泄漏**指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。

如果内存不需要时，没有经过生命周期的**释放期**，那么就存在**内存泄漏**。

无用的内存还在占用，得不到释放和归还。比较严重时，无用的内存会持续递增，从而导致整个系统卡顿，甚至崩溃。内存泄漏通俗的理解就是：程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。

在C++中，因为是手动管理内存，内存泄漏是经常出现的事情。而现在流行的C#和Java等语言采用了自动垃圾回收方法管理内存，正常使用的情况下几乎不会发生内存泄漏。在前端开发中，浏览器采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有bug，因此会产生内存泄漏。

#### **A.JavaScript中涉及内存泄漏的几种原因：**

> **1.全局变量引起的内存泄漏：**
> 根据JavaScript的垃圾回收机制我们知道，全局变量是不会被回收的，所以一些意外的、不需要的全局变量多了，没有释放，就造成了内存泄漏。
> 例：不断地创建全局变量，不管有没有用到它们，它们都将滞留在程序的整个执行过程中。如果这些变量是深层嵌套对象，将会浪费大量内存。

```
var a = { ... }var b = { ... }function hello() {
  c = a;  // 这是一个你没有意识到的全局变量}
```

> 如果你试图访问一个此前没有声明过的变量，那么将在全局作用域中创建一个变量。在上面的例子中，c 是没有使用 var 关键字显式创建的变量/对象。
> **2.闭包：**
> 闭包其实也是跟全局变量挂钩了，但是闭包只是因为被全局变量引用了，内部的变量因为被闭包引用得不到释放，也会造成内存泄漏。
> 因为Javascript范围的限制，许多实现依赖Javascript闭包。闭包可以导致内存泄漏是因为内部方法保持一个对外部方法变量的引用，所以尽管方法返回了内部方法还可以继续访问在外部方法中定义的私有变量。最好的做法是在页面重载前断开所有的事件处理器。
> 举例说明：

```
var theThing = null; 
var replaceThing = function () { 
    var priorThing = theThing; 
    var unused = function () { 
        if (priorThing) {       
            console.log("hi");     
        }   
    }; 
    theThing = {     
        longStr: new Array(100).join('*'),
        someMethod: function () {       
            console.log(someMessage);  
        }   
    }; 
};
setInterval(replaceThing, 1000);
```

> 运行上面的代码，会发现已经造成了大量的内存泄露，每秒泄露1M的内存，显然光靠垃圾回收器是无法帮助你的了。由上面的代码来看，似乎是longstr在每次replaceThing调用的时候都没有得到回收。每一个theThing结构都含有一个longstr结构列表。每一秒当我们调用 replaceThing, 它就会把当前的指向传递给priorThing。但是到这里我们也会看到并没有什么问题，因为priorThing每回也是先解开上次函数的指向才会接受新的赋值。并且所有的这一切都是发生在replaceThing函数体当中，按常理来说当函数体结束之后，函数中的本地变量也将会被垃圾回收器回收，也就不会出现内存泄露的问题了，但是为什么会出现上面的错误呢？
> 这是因为longstr的定义是在一个闭包中进行的，而它又被其他的闭包所引用，js规定，在闭包中引入闭包外部的变量时，当闭包结束时此对象无法被垃圾回收。
> **3.计时器、回调、监听等事件没有移除：**
> 计时器、回调、事件监听等没有清除是一直存在的，一直存在没有被释放就会造成内存泄漏。
> 为了增强网站的交互性或者是制作一些浮华的动画，你可能会创建大量的事件监听器。而用户在你的单页面应用中移向其他页面时，你又忘记移除这些监听器，那么也可能会导致内存泄漏。当用户在这些页面来回移动的时候，这些监听器会不断增加。
> **4.给DOM添加属性或方法：**
> 给DOM添加点击方法、添加属性等，也会造成变量引用得不到释放，造成内存泄漏。
> 例移除 DOM 元素：这个问题很常见，类似于全局变量导致的内存泄漏。DOM 元素存在于对象图内存和 DOM 树中。用例子来解释可能会更好：

```
var terminator = document.getElementById('terminate');
var badElem = document.getElementById('toDelete');
terminator.addEventListener('click', function()  {memory
  badElem.remove();});
```

> 在你通过 id = ‘terminate’ 点击了按钮之后，toDelete 会从 DOM 中移除。不过，由于它仍然被监听器引用，为这个对象分配的内存并不会被释放。

```
var terminator = document.getElementById('terminate');
terminator.addEventListener('click', function()  {
  var badElem = document.getElementById('toDelete');
  badElem.remove();});
```

> badElem 是局部变量，在移除操作完成之后，内存将会被垃圾回收器回收。
> **5.循环引用**
> 简单的例子：一个 DOM 对象被一个 Javascript 对象引用，与此同时又引用同一个或其它的 Javascript 对象，这个 DOM 对象可能会引发内存泄露。这个 DOM 对象的引用将不会在脚本停止的时候被垃圾回收器回收。要想破坏循环引用，引用 DOM 元素的对象或 DOM 对象的引用需要被赋值为null。

最基础的造成内存泄漏的几个点，应该还有更深层次一点的。而内存泄漏最核心的还是因为垃圾机制，全局变量或者是被全局变量引用，垃圾机制就无法回收，要是一直需要使用的还好，要是一些用完一次就不再使用的没有释放，那么积累的多了就容易造成内存溢出。

#### **B.内存泄漏的识别方法**

内存泄漏对开发者来说一般很难检测因为它们是由一些大量代码中的意外的错误引起的，但它在系统内存不足前并不影响程序的功能。这就是为什么会有人在很长时间的测试期中收集应用程序性能指标来测试性能。

**经验法则:**如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存的占用情况。

**最简单的检测内存泄漏的方法：**用任务管理器检查内存使用情况。在Chrome浏览器的新选项卡中打开应用并查看内存使用量是不是越来越多。

## 2、xss和csrf的原理及防御措施 

## 3、混合开发的原理 

## 4、v-on可以绑定多个方法吗 

## 5、客户端渲染和服务端渲染的区别 

## 6、React类组件和函数组件有什么区别 

## 7、flex布局有哪些常用的属性？ 

## 8、JS中常见的设计模式及其使用场景 

## 9、Vue中template的编译过程 

## 10、React的事件机制？ 

## 11、React-router-dom内部是怎么实现的，怎么做路由守卫？ 12、小程序与普通网页开发有什么区别？ 